*Generics классы*

1) Принцип подстановки Барбары Лисков гласит, что объекты должны быть
заменяемыми своими подтипами (потомками) без нарушения корректной работы этой
программы. Это означает, что если у нас есть класс родитель и класс-потомок,
то код, использующий объект родителя должен работать корректно и с объектом
потомка. На этом базируется идея дженериков.

2) Дженерики появились начиная с 5ой джавы. Они позволяют обозначить сущности,
которые могут хранить в себе данные определенного типа. Бывают классы и методы
generics.

3) Ковариантность - сохранение иерархии исходных типов в производных
(наследных) типах в том же порядке. Например, если Кошка это подтип от
Животное, то, Множество<Кошки> - это подтип от Множество<Животные>,
следовательно, Множество<Животные> = Множество<Кошки>.

4) Контрвариантность - это обращение иерархии исходных типов на
противоположную в производных типах. Например, если Кошка - это подтип от
Животные, то Множество<Животные> это подтип от множества <Кошки>, следовательно,
Множество<Кошки> = Множество<Животные>

5) Инвариантность - это отсутствие наследования между производными типами. Если
Кошка - это подтип Животные, то Множество<Кошки> не является подтипом
Множество<Животные> и Множество<Животные> не является подтипом Множество<Кошки>.

5.1) Массивы ковриантны, Дженерики инвариантны, Wildcards могут быть как
ковариантны так и контрвариантны, зависит от ограничения конкретной wildcard.

5.2) См. примеры Ковариантности, Контрвариантности и Инвариантности в коде.

6) Когда мы записываем при объявлении класса или метода идентификатор в угловых
скобках, например <T> или <E>, то мы создаем переменную типа. Переменная типа
это неквалифицированный идентификатор, который можно использовать в качестве
типа в теле класса или метода.

7) Чаще дженерики используются вместе с наследованием т.е. указывается не просто
наличие дженерик типа, а от какого класса этот тип наследуется. Например:
<T extends Animal, S extends Action>. В качестве границы может выступать класс,
интерфейс или enum. Писать с super нельзя.

8) После компиляции все, что находится в <> пропадает и превращается в обычный
java-код это называется Type Erasure.

9) Передавать в качестве дженерика можно только ссылочный тип, интерфейс или
enum.

10) Можно указать дженерик-класс со сколько угодным количеством параметров.

11) Набор рекомендаций по обозначению дженериков:
    E - element, для элементов параметризованных коллекций
    K - key, для ключей map-структур
    V - value, для значений map-структур
    N - number, для чисел
    T - type, для обозначения типа параметра в произвольных классах.
    Остальные буквы - применяются когда в дженерик-классе несколько параметров.

12) Type inference - указав значения дженерика слева, в операторе diamond (<>)
эти значения указывать не нужно. Компилятор понимает их из контекста.

13) Если объявить дженерик класс без дженерик-параметризации, то такой класс
будет называться сырым - raw type.

*Generics интерфейс*

1) По сути, с дженерик интерфейсами все то же самое, что и с дженерик-классами.
См. пример объявления дженерик-интерфейса в коде.

2) Дженерик классы и интерфейсы вместе называют дженерик - типами.

*Generics методы*

1) Типизированными могут быть как параметры метода, так и возвращаемый им тип.

2) Использовать дженерик методы нужно чтобы по 10 раз не переписывать один метод
для разных типов данных.

3) Такие методы позволяют работать с разными типами параметров. Если к разным
типам можно безопасно применять одну и ту же логику, нужно использовать
дженерик-метод.

4) Пример объявления дженерик метода:
    public <T, S> T handleSmth(T t, S s){}
    <T, S> - объявление дженериков с которыми этот метод будет работать
    T - тип возвращаемого значения
    T t, S s - переменные на вход, см. внимательно примеры в коде

*Wildcard*

1) Wildcard - обозначается как <?> или <? extends ...> или <? super ...>. Их
удобно использовать для объявления переменных и параметров методов совместно с
Collections Framework.

2) <?> == <? extends Object>

3) принцип PECS - producer extends, consumer super означает, что если wildcard
объявлена через <? extends ...>, то это producer и из такой коллекции можно
только читать значения, а если через <? super ...>, то это consumer и в такую
коллекцию значения можно только добавлять.

4) Wildcards могут быть как ковариантны так и контрвариантны, зависит от
ограничения конкретной wildcard. Если <? extends ...>, то такая коллекция
ковариантна, если <? super ...>, то такая коллекция контрвариантна.

5) Что бы производить требуемые манипуляции с коллекциями wildcard, например,
reverse листа, используй паттерн wildcard capture (см. patterns).

6) Не используй wildcard если нужно производить и запись и чтение с этой
коллекцией.